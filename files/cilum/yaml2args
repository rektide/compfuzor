#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'USAGE'
Usage: yaml2set.sh [-r ROOT] FILE [FILE...]
Flatten YAML nested keys into --set=path=value lines.
Options:
  -r, --root ROOT   Optional prefix to prepend to every path (e.g. 'myapp').
USAGE
}

#
# Notes:
#- Requires yq
#- Arrays are represented with [index], e.g. key.list[0].item=value
#- If ROOT is provided and the top-level is an array, output looks like ROOT[0]... (no extra dot).

ROOT=""
FILES=()

# Parse args
while [[ $# -gt 0 ]]; do
  case "$1" in
  -r | --root)
    [[ $# -ge 2 ]] || {
      echo "Missing value for $1" >&2
      exit 2
    }
    ROOT="$2"
    shift 2
    ;;
  -h | --help)
    usage
    exit 0
    ;;
  --)
    shift
    while [[ $# -gt 0 ]]; do
      FILES+=("$1")
      shift
    done
    break
    ;;
  -*)
    echo "Unknown option: $1" >&2
    exit 2
    ;;
  *)
    FILES+=("$1")
    shift
    ;;
  esac
done

[[ ${#FILES[@]} -gt 0 ]] || {
  echo "No input files provided." >&2
  usage
  exit 2
}

have() { command -v "$1" >/dev/null 2>&1; }

run_with_yq() {
  local root="$1"
  shift
  local f
  for f in "$@"; do
    yq -r --arg root "$root" '
      def pstr($p):
        reduce $p[] as $x
          (""; . + (if ($x|type) == "string"
                    then (if . == "" then "" else "." end) + ($x|tostring)
                    else "["+($x|tostring)+"]"
                    end));
      paths(scalars) as $p
      | "--set="
        + (if $root == "" then "" else ($root + (if ($p[0]|type) == "number" then "" else "." end)) end)
        + (pstr($p))
        + "="
        + (getpath($p) | tostring)
    ' -- "$f"
  done
}

# Dispatcher: prefer yq, then python+PyYAML, then ruby
if have yq; then
  run_with_yq "$ROOT" "${FILES[@]}"
else
  echo "Error: need yq." >&2
  exit 1
fi
